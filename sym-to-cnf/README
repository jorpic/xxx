Тут лежат утилиты для экспериментов с преобразованием набора ограничений в
CNF. Пример использования можно посмотреть в test.sh.

==== random-sym
Настоящих примеров ограничений у меня пока нет, поэтому приходится играться со
случайными. Их можно нагенерировать с помощью этой утилиты. Вот какие
аргументы она ожидает (все обязательные):
  --total-vars   -- общее количество переменных
  --vars-in-sym  -- на какое количество переменных будет накладываться
  ограничение
  --sym-size     -- количество строчек в табличном представлении ограничения

Например:
  $ random-sym --total-vars=64 --vars-in-sym=25 --sym-size=50000 | sort -ru

Здесь из 64-х переменных случайным образом выбирается 25 и генерируется 50тыс.
присваиваний этим переменным случайных значений. `sort -ru` на всякий случай, чтобы
исключить дубликаты.

Формат ограничения такой:
  - одна строчка с номерами переменных, участвующих в ограничении
    - [3,5,13,31]
  - много строчек -- шеснадцитеричные числа, каждый бит обозначает
    присваивание соответствующей переменной нуля или единицы
    - 0f <=> x3=1 ∧ x5=1 ∧ x13=1 ∧ x31=1
    - 02 <=> x3=0 ∧ x5=1 ∧ x13=0 ∧ x31=0


==== sym-to-cnf
Берёт несколько ограничений и преобразовывает их в CNF.

Обязательные аргументы:
  --max-var    -- должно быть такое же значение как и total-vars в random-sym
  --method     -- пока только tseitin
  +RTS -K20M   -- чтобы стек не переполнялся

В stdin ожидается одно или несколько ограничений в том формате, как их
ramdom-sym генерирует.

Например:
  $ sym-to-cnf --total-vars=64 --method=tseitin +RTS -K20M


==== check-res
Чтобы хоть как-то проверить правильность полученной CNF, можно подобрать
подходящие значения переменных (например с помощью minisat) и поискать
соответствующие строки в ограничениях (этим и занимается check-res).

Аргументы позиционные, не именованные:
  - первый -- имя файла с результатом SAT solver'а
  - остальные -- имена файлов с ограничениями
